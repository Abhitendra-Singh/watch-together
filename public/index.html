<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Watch Together</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #player {
            width: 100%;
            aspect-ratio: 16/9;
        }
        .chat-message {
            max-width: 80%;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-6xl mx-auto">
        <h1 class="text-4xl font-bold text-center mb-4">Watch Together</h1>
        <p id="status" class="text-center text-yellow-400 mb-6">Status: Disconnected</p>

        <!-- Connection and Video URL Section -->
        <div id="setup-section" class="bg-gray-800 p-4 rounded-lg mb-4 flex flex-col sm:flex-row gap-4 items-center">
            <div class="flex-grow w-full">
                <label for="room-name" class="block text-sm font-medium text-gray-300 mb-1">Room Name</label>
                <input type="text" id="room-name" placeholder="Enter a room name to join or create" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none">
            </div>
            <div class="flex-grow w-full">
                <label for="youtube-url" class="block text-sm font-medium text-gray-300 mb-1">YouTube URL</label>
                <input type="text" id="youtube-url" placeholder="Paste a YouTube video URL" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none">
            </div>
             <div class="w-full sm:w-auto flex flex-col sm:flex-row gap-2 pt-2 sm:pt-6">
                <button id="connect-btn" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Connect</button>
                <button id="load-video-btn" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition-colors" disabled>Load Video</button>
            </div>
        </div>

        <!-- Main Content: Video and Chat -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Video Player -->
            <div class="lg:col-span-2 bg-black rounded-lg overflow-hidden shadow-lg">
                <div id="player-container" class="w-full h-full bg-black flex items-center justify-center">
                   <div id="player"></div>
                </div>
            </div>

            <!-- Chat Panel -->
            <div id="chat-section" class="bg-gray-800 rounded-lg flex flex-col h-[50vh] lg:h-auto" style="display:none;">
                <div class="p-4 border-b border-gray-700">
                    <h2 class="text-xl font-semibold">Chat</h2>
                </div>
                <div id="chat-messages" class="flex-grow p-4 space-y-4 overflow-y-auto">
                    <!-- Messages will appear here -->
                </div>
                <div class="p-4 border-t border-gray-700">
                    <form id="chat-form" class="flex gap-2">
                        <input type="text" id="username-input" placeholder="Your Name" class="w-1/3 bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none">
                        <input type="text" id="message-input" placeholder="Type a message..." class="flex-grow bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none" required>
                        <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Send</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const SIGNALING_SERVER_URL = window.location.origin;
        const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }]; // Public STUN server

        // --- GLOBAL STATE ---
        let socket;
        let peerConnection;
        let syncChannel;
        let chatChannel;
        let roomName;
        let isInitiator = false;
        let isPlayerReady = false;
        let receivedPlayerStateFromPeer = false; // Flag to prevent event loops

        // --- UI ELEMENTS ---
        const statusEl = document.getElementById('status');
        const connectBtn = document.getElementById('connect-btn');
        const roomNameInput = document.getElementById('room-name');
        const youtubeUrlInput = document.getElementById('youtube-url');
        const loadVideoBtn = document.getElementById('load-video-btn');
        const chatSection = document.getElementById('chat-section');
        const chatForm = document.getElementById('chat-form');
        const usernameInput = document.getElementById('username-input');
        const messageInput = document.getElementById('message-input');
        const chatMessages = document.getElementById('chat-messages');
        const setupSection = document.getElementById('setup-section');

        // --- YOUTUBE PLAYER API ---
        let player;
        window.onYouTubeIframeAPIReady = function() {
            player = new YT.Player('player', {
                height: '100%',
                width: '100%',
                videoId: 'M7lc1UVf-VE', // Default video
                playerVars: { 'autoplay': 0, 'controls': 1, 'rel': 0 },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        };
        
        function onPlayerReady(event) {
            isPlayerReady = true;
            statusEl.textContent = 'Status: YouTube Player Ready. Enter a room and connect.';
        }

        function onPlayerStateChange(event) {
            if (receivedPlayerStateFromPeer) {
                receivedPlayerStateFromPeer = false;
                return;
            }
            if (!syncChannel || syncChannel.readyState !== 'open') return;

            const time = player.getCurrentTime();
            switch (event.data) {
                case YT.PlayerState.PLAYING:
                    syncChannel.send(JSON.stringify({ type: 'play', time }));
                    break;
                case YT.PlayerState.PAUSED:
                    syncChannel.send(JSON.stringify({ type: 'pause', time }));
                    break;
                case YT.PlayerState.BUFFERING: // Often precedes a seek
                    // Seeking is handled implicitly by play/pause at a new time.
                    // A dedicated seek event could be added if needed.
                    break;
            }
        }
        
        // Load YouTube API script
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);


        // --- WEBRTC AND SIGNALING LOGIC ---
        function connect() {
            roomName = roomNameInput.value.trim();
            if (!roomName) {
                alert('Please enter a room name.');
                return;
            }

            socket = io(SIGNALING_SERVER_URL);
            setupSocketListeners();
            socket.emit('join_room', roomName);
            
            connectBtn.disabled = true;
            roomNameInput.disabled = true;
            statusEl.textContent = `Status: Joining room "${roomName}"...`;
        }

        function setupSocketListeners() {
            socket.on('room_joined', () => {
                statusEl.textContent = `Status: Joined room "${roomName}". Waiting for a peer...`;
            });
            
            socket.on('room_full', () => {
                alert('The room is full.');
                statusEl.textContent = 'Status: Disconnected';
                connectBtn.disabled = false;
                roomNameInput.disabled = false;
                socket.disconnect();
            });

            socket.on('start_peer_connection', (data) => {
                isInitiator = data.isInitiator;
                statusEl.textContent = 'Status: Peer found. Establishing connection...';
                createPeerConnection();
                if (isInitiator) {
                    createDataChannels();
                    peerConnection.createOffer()
                        .then(offer => peerConnection.setLocalDescription(offer))
                        .then(() => {
                            socket.emit('signal', { type: 'offer', sdp: peerConnection.localDescription, roomName });
                        })
                        .catch(handleError);
                }
            });

            socket.on('signal', async (data) => {
                if (data.type === 'offer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    socket.emit('signal', { type: 'answer', sdp: peerConnection.localDescription, roomName });
                } else if (data.type === 'answer') {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
                } else if (data.type === 'ice-candidate') {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    } catch (e) {
                        console.error('Error adding received ice candidate', e);
                    }
                }
            });

            socket.on('peer_disconnected', () => {
                statusEl.textContent = 'Status: Peer disconnected. You can wait for another peer.';
                closePeerConnection();
            });
        }

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    socket.emit('signal', { type: 'ice-candidate', candidate: event.candidate, roomName });
                }
            };

            peerConnection.ondatachannel = event => {
                if (event.channel.label === 'syncChannel') {
                    syncChannel = event.channel;
                    setupSyncChannelListeners();
                } else if (event.channel.label === 'chatChannel') {
                    chatChannel = event.channel;
                    setupChatChannelListeners();
                }
            };
            
             peerConnection.onconnectionstatechange = () => {
                if (peerConnection.connectionState === 'connected') {
                    statusEl.textContent = `Status: Connected to peer in room "${roomName}"!`;
                    loadVideoBtn.disabled = false;
                    chatSection.style.display = 'flex';
                    setupSection.classList.add('hidden'); // Hide setup after connection
                }
            };
        }
        
        function createDataChannels() {
            syncChannel = peerConnection.createDataChannel('syncChannel');
            chatChannel = peerConnection.createDataChannel('chatChannel');
            setupSyncChannelListeners();
            setupChatChannelListeners();
        }

        function setupSyncChannelListeners() {
            syncChannel.onmessage = event => {
                const data = JSON.parse(event.data);
                receivedPlayerStateFromPeer = true;

                if (data.type === 'load') {
                    player.loadVideoById(data.videoId);
                } else if (data.type === 'play') {
                    player.seekTo(data.time, true);
                    player.playVideo();
                } else if (data.type === 'pause') {
                    player.seekTo(data.time, true); // Ensure time is synced before pausing
                    player.pauseVideo();
                }
            };
             syncChannel.onopen = () => console.log('Sync channel opened');
             syncChannel.onclose = () => console.log('Sync channel closed');
        }
        
        function setupChatChannelListeners() {
            chatChannel.onmessage = event => {
                const msg = JSON.parse(event.data);
                appendChatMessage(msg.username, msg.message, false);
            };
             chatChannel.onopen = () => console.log('Chat channel opened');
             chatChannel.onclose = () => console.log('Chat channel closed');
        }

        function closePeerConnection() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
             if (syncChannel) syncChannel.close();
             if (chatChannel) chatChannel.close();
             loadVideoBtn.disabled = true;
             chatSection.style.display = 'none';
             setupSection.classList.remove('hidden');
        }

        // --- UI EVENT HANDLERS ---
        connectBtn.addEventListener('click', connect);

        loadVideoBtn.addEventListener('click', () => {
            const url = youtubeUrlInput.value;
            const videoId = extractVideoID(url);
            if (videoId) {
                if (isPlayerReady) {
                    player.loadVideoById(videoId);
                     if (syncChannel && syncChannel.readyState === 'open') {
                        syncChannel.send(JSON.stringify({ type: 'load', videoId: videoId }));
                     }
                }
            } else {
                alert('Invalid YouTube URL.');
            }
        });

        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const message = messageInput.value.trim();
            const username = usernameInput.value.trim() || 'Anonymous';
            if (message && chatChannel && chatChannel.readyState === 'open') {
                const msg = { username, message };
                chatChannel.send(JSON.stringify(msg));
                appendChatMessage(username, message, true);
                messageInput.value = '';
            }
        });
        
        function appendChatMessage(username, message, isSender) {
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message', 'p-3', 'rounded-lg', 'flex', 'flex-col', isSender ? 'bg-blue-600' : 'bg-gray-600', isSender ? 'ml-auto' : 'mr-auto');
            
            messageDiv.innerHTML = `
                <div class="flex items-baseline gap-2">
                    <p class="font-bold text-sm">${username}</p>
                    <p class="text-xs text-gray-300">${timestamp}</p>
                </div>
                <p class="text-white mt-1">${message}</p>
            `;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight; // Auto-scroll to bottom
        }

        // --- UTILITY FUNCTIONS ---
        function extractVideoID(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function handleError(error) {
            console.error('Error: ', error);
            statusEl.textContent = 'Status: An error occurred.';
        }

    </script>
</body>
</html>
